{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Ecotracer Analytics","text":"<p>Ecotracer Analytics is a Python library for advanced analysis of Ecopath with Ecosim (EwE) Ecotracer models. It provides tools to extract linear system representations of contaminant flows, calculate equilibrium states analytically, and perform \"reverse\" parameter estimation.</p>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Linear System Extraction: Convert Ecotracer dynamics into Matrix form. $$ \\frac{dC}{dt} = b - M \\cdot C $$.</li> <li>Simulate ODE: Simulate the ODE overtime without the need to solve for a stable ecosim parameterisation.</li> <li>Analytic Equilibrium: Solve for steady-state concentrations without time-stepping simulations. $$ C = M^{-1} \\cdot b $$</li> <li>Parameter Analysis: Estimate Ecotracer parameters (direct absorption rates, decay, etc.) that reproduce a specific observed equilibrium.</li> <li>Uncertainty Propagation: Calculate analytic confidence intervals for predictions based on parameter uncertainty.</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"<pre><code>pip install ecotracer-analytics\n</code></pre>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<pre><code>import pyewe as ewe\nfrom ecotracer_analytics import EcopathSource, EcotracerSource, calculate_equilibrium\n\n# 1. Load your EwE Model\nmodel = ewe.EwEScenarioInterface(\"MyModel.eiixml\")\ncore = model._core_instance\n\n# 2. Wrap sources\npath_source = EcopathSource(core)\ntracer_source = EcotracerSource(core)\n\n# 3. Calculate Equilibrium\nC_eq = calculate_equilibrium(path_source, tracer_source)\nprint(\"Equilibrium Concentrations:\", C_eq)\n</code></pre>"},{"location":"analytical_r_formulation.html","title":"Analytical Formulation of the Residual Vector \\(\\mathbf{r}\\)","text":"<p>In the Ecotracer reverse workflow, the system of equations for the parameter set \\(\\theta\\) is formulated as:</p> \\[\\mathbf{K}(C_{obs}) \\cdot \\theta = \\mathbf{r}(C_{obs})\\] <p>The vector \\(\\mathbf{r}(C_{obs})\\) represents the \"Fixed Residuals\"\u2014the net rate of change in concentration for each group that occurs independently of the adjustable parameters. Calculating this analytically avoids the potential floating-point errors associated with large sparse matrix multiplications (\\(M_{const} \\cdot C_{obs}\\)). </p>"},{"location":"analytical_r_formulation.html#1-living-groups-biota","title":"1. Living Groups (Biota)","text":"<p>For a living group \\(i\\), the residual represents the concentration lost to natural and fishing mortality. This loss must be balanced by variable gains (consumption) in the optimization.</p> \\[r_i = Z_i \\cdot C_{i, obs}\\] <p>Where: *   \\(Z_i\\) is the total mortality rate: \\(Z_i = F_i + M2_i + M0_i + E_i\\). *   \\(F_i\\): Fishing mortality. *   \\(M2_i\\): Predation mortality. *   \\(M0_i\\): Other mortality. *   \\(E_i\\): Emigration rate.</p>"},{"location":"analytical_r_formulation.html#2-detritus-groups","title":"2. Detritus Groups","text":"<p>For detritus, the residual captures the net flow from fixed sources (mortality and discards) versus fixed sinks (consumption by others and export).</p> \\[r_i = \\left( \\frac{\\sum Q_{i,pred}}{B_i} + \\text{Export}_i \\right) C_{i, obs} - \\sum_{j \\in \\text{Living}} \\left( M0_j \\cdot C_{j, obs} \\cdot \\text{Fate}_{j \\to i} + \\text{Discards}_{j \\to i} \\right)\\] <p>Key Terms: *   Consumption Sink: \\(\\frac{\\sum Q_{i,pred}}{B_i}\\) is the rate at which detritus \\(i\\) is consumed by all predators. *   Export Sink: Physical export or burial rate of detritus. *   Mortality Source: The concentration inflow from the non-predatory mortality (\\(M0\\)) of all living groups \\(j\\), scaled by the fraction that goes to detritus group \\(i\\). *   Discard Source: Concentration inflow from fishery discards.</p>"},{"location":"analytical_r_formulation.html#3-the-environment-nutrientswater","title":"3. The Environment (Nutrients/Water)","text":"<p>The environment (index 0) acts as the ultimate sink for remineralized material. In the current formulation, detritus export is treated as a return to the environment.</p> \\[r_0 = - \\sum_{k \\in \\text{Detritus}} (\\text{Export}_k \\cdot C_{k, obs})\\] <p>Note: If the <code>base_inflow</code> is treated as a fixed constant, it is subtracted from this residual (\\(r_0 = \\dots - \\text{Inflow}\\)).</p>"},{"location":"analytical_r_formulation.html#4-summary-table","title":"4. Summary Table","text":"Component Formula for \\(r_i\\) Physical Interpretation Living \\(Z_i \\cdot C_i\\) Concentration lost to mortality. Detritus \\((\\text{Loss Rate}) C_i - (\\text{Gain Flux})\\) Net imbalance from fixed flows. Environment \\(-\\sum (\\text{Export}_k \\cdot C_k)\\) Total remineralization gain."},{"location":"analytical_r_formulation.html#benefits-of-analytical-calculation","title":"Benefits of Analytical Calculation","text":"<ol> <li>Precision: Eliminates rounding errors from \\(M \\cdot C\\) operations involving near-zero coefficients.</li> <li>Sparsity: Direct calculation only iterates over non-zero biological links (diet and fate).</li> <li>Stability: All components are derived from positive physical rates, ensuring the residual scales linearly and predictably with observed concentrations.</li> </ol>"},{"location":"api.html","title":"API Reference","text":""},{"location":"api.html#linear-system","title":"Linear System","text":""},{"location":"api.html#calculate_equilibrium","title":"<code>calculate_equilibrium</code>","text":"<pre><code>def calculate_equilibrium(path_source: EcopathSource, tracer_source: EcotracerSource) -&gt; np.ndarray\n</code></pre> <p>Solves the linear system \\(M \\cdot C = b\\) to find the steady-state concentrations.</p>"},{"location":"api.html#calculate_coefficient","title":"<code>calculate_coefficient</code>","text":"<pre><code>def calculate_coefficient(path_source: EcopathSource, tracer_source: EcotracerSource) -&gt; np.ndarray\n</code></pre> <p>Constructs the coefficient matrix \\(M\\) (size \\((N+1) \\times (N+1)\\)).</p>"},{"location":"api.html#calculate_intercept","title":"<code>calculate_intercept</code>","text":"<pre><code>def calculate_intercept(path_source: EcopathSource, tracer_source: EcotracerSource) -&gt; np.ndarray\n</code></pre> <p>Constructs the intercept vector \\(b\\) (size \\(N+1\\)). </p>"},{"location":"api.html#dynamics","title":"Dynamics","text":""},{"location":"api.html#simulate_dynamics","title":"<code>simulate_dynamics</code>","text":"<pre><code>def simulate_dynamics(\n    path_source: EcopathSource,\n    tracer_source: EcotracerSource,\n    y0: np.ndarray,\n    t_span: Tuple[float, float],\n    t_eval: Optional[np.ndarray] = None,\n    method: str = \"RK45\",\n    **kwargs: Any\n) -&gt; scipy.integrate.OdeResult\n</code></pre> <p>Simulates the system forward in time (\\(\\frac{dC}{dt} = b - M \\cdot C\\)).</p>"},{"location":"api.html#build_state_vector","title":"<code>build_state_vector</code>","text":"<pre><code>def build_state_vector(\n    path_source: EcopathSource,\n    env_conc: float,\n    group_concs: np.ndarray\n) -&gt; np.ndarray\n</code></pre> <p>Helper to construct the state vector \\(y = [C_{env}, C_1, \\dots, C_N]\\).</p>"},{"location":"api.html#reverse-analysis","title":"Reverse Analysis","text":""},{"location":"api.html#parameterdefinition","title":"<code>ParameterDefinition</code>","text":"<pre><code>class ParameterDefinition:\n    def __init__(self, path_source: EcopathSource, tracer_source: EcotracerSource)\n</code></pre> <p>Defines the mapping between the flat parameter vector \\(\\theta\\) and the Ecotracer model structure. Handles priors, bounds, and fixed statuses.</p>"},{"location":"api.html#linearconstraintbuilder","title":"<code>LinearConstraintBuilder</code>","text":"<pre><code>class LinearConstraintBuilder:\n    def __init__(self, path_source: EcopathSource, tracer_source: EcotracerSource, param_def: ParameterDefinition)\n\n    def build(self, C_obs: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Constructs the linear constraint system \\(\\mathbf{K} \\cdot \\theta = \\mathbf{r}\\).</p>"},{"location":"api.html#constrainedsolver","title":"<code>ConstrainedSolver</code>","text":"<pre><code>class ConstrainedSolver:\n    def solve(\n        self, \n        K: np.ndarray, \n        r: np.ndarray, \n        param_def: ParameterDefinition, \n        x0: Optional[np.ndarray] = None\n    ) -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Finds the optimal parameter set \\(\\theta^*\\) that satisfies \\(\\mathbf{K}\\theta = \\mathbf{r}\\) and bounds, minimizing the distance to the priors.</p>"},{"location":"api.html#constrainedsolversample","title":"<code>ConstrainedSolver.sample</code>","text":"<pre><code>    def sample(\n        self,\n        K: np.ndarray,\n        r: np.ndarray,\n        param_def: ParameterDefinition,\n        n_samples: int = 1000,\n        sigma: float = 0.05,\n        x_center: Optional[np.ndarray] = None,\n        x_anchor: Optional[np.ndarray] = None\n    ) -&gt; np.ndarray\n</code></pre> <p>Samples feasible parameter sets from the nullspace of the constraints using a Hit-and-Run algorithm with truncated Gaussian steps. *   <code>sigma</code>: Standard deviation of the sampling step size. *   <code>x_center</code>: The center of the distribution (defaults to priors). *   <code>x_anchor</code>: A valid starting point on the manifold (defaults to result of <code>solve</code>).</p> <p>```</p>"},{"location":"parameter_analysis.html","title":"Parameter Analysis Workflow","text":"<p>Estimating Ecotracer parameters are difficult. It is often easier to measure observed contaminant concentrations in fisheries then to estimate metabolic decay rates, assimilation efficiencies, direct absorption rates etc. In many circumstances, modellers will be more confident about contaminant concentration observations that the model parameterisation and are forced to work backwards tinkering, with parameters to reproduce observations.</p> <p>The parameter analysis workflows allows users to explore the parameter space of Ecotracer constrained by the observed contaminant concentrations, and sample from parameter space that is guaranteed to reproduce observations. </p> <p>It is important to note that users will still need a understanding of reasonable parameters given that Ecotracer is unidentifiable when fitting to a single timestep of observed concentrations.</p> <p>This is useful for: *   Calibration: Fitting a model to field data. *   Exploration: Understanding the set of parameters that yield the same result. *   Uncertainty Quantification: Generating ensembles of valid parameters to propagate uncertainty in non-equilibrium conditions.</p>"},{"location":"parameter_analysis.html#mathematical-theory","title":"Mathematical Theory","text":"<p>The Ecotracer system, assuming the underlying fishery dynamics are constant, are governed by a simple ODE,</p> \\[ \\frac{dC}{dt}= b - M \\cdot C\\] <p>where the \\(M \\in \\mathbb{R}^{(n \\times n)}\\) is constructed from Ecopath and Ecotracer parameters and governs gains and losses between functional groups that are directly proportional to contaminant concentration. The vector \\(b \\in \\mathbb{R}^n\\) describes forcing flows such as base inflow and immigration. This formulation gives us functionality beyond the Ecotracer module in EwE, to examine how different forcing, beyond the environmental inflows, drive change.</p> <p>To explore the parameter space we can re-express the linear system in terms of the parameters,</p> \\[ K \\cdot \\theta = r \\] <p>where \\(K \\in \\mathbb{R}^{n \\times P}\\) and is a function of Ecopath state and Concentration but independent of the parameters \\(\\theta \\in \\mathbb{R}^P\\).</p>"},{"location":"parameter_analysis.html#1-optimization-the-best-estimate","title":"1. Optimization (The \"Best\" Estimate)","text":"<p>Given that the new system does not yield a unique solution for \\(\\theta\\), if there is a solution, there will be infinitely many. Before we begin sampling from possible solutions we want to inform sampling to be centered around realistic values, but values that are consistent with the observed equilibrium.</p> <p>With a best initial guess \\(\\theta_0\\), we can formulate a center to inform sampling using a quadratic programming problem.</p> \\[  \\begin{align*}     &amp;\\min_\\theta || \\theta - \\theta_{0} ||^2 \\\\     &amp;\\text{s.t.} \\quad \\mathbf{K} \\theta = \\mathbf{r} \\\\     &amp;\\theta_{min} \\le \\theta \\le \\theta_{max}  \\end{align*} \\]"},{"location":"parameter_analysis.html#2-nullspace-sampling-the-ensemble","title":"2. Nullspace Sampling (The Ensemble)","text":"<p>Usually, the system is underdetermined (more parameters than equations), there is a subspace of valid solutions.</p> <p>We explore this space using a Hit-and-Run sampler. Any valid solution \\(\\theta\\) can be expressed as: $$ \\theta = \\theta_{particular} + \\mathbf{N} \\cdot z $$</p> <p>Where: *   \\(\\theta_{particular}\\): A valid solution (e.g., \\(\\theta^*\\)). *   \\(\\mathbf{N}\\): The matrix of nullspace basis vectors (\\(\\mathbf{K} \\cdot \\mathbf{N} = 0\\)). *   \\(z\\): A vector of coefficients.</p> <p>The sampler randomly moves in the \\(z\\)-space, ensuring the resulting \\(\\theta\\) remains within the physical bounds \\([\\theta_{min}, \\theta_{max}]\\).</p>"},{"location":"parameter_analysis.html#usage","title":"Usage","text":""},{"location":"parameter_analysis.html#1-setup-and-build-constraints","title":"1. Setup and Build Constraints","text":"<pre><code>from ecotracer_analytics import (\n    EcopathSource, EcotracerSource, calculate_equilibrium,\n    ParameterDefinition, LinearConstraintBuilder, ConstrainedSolver\n)\n\n# Load Data\npath_source = EcopathSource(core)\ntracer_source = EcotracerSource(core)\nC_obs = calculate_equilibrium(path_source, tracer_source) # Or provide your own\n\n# Define Parameters\nparam_def = ParameterDefinition(path_source, tracer_source)\n\n# Build K and r\nbuilder = LinearConstraintBuilder(path_source, tracer_source, param_def)\nK, r = builder.build(C_obs)\n</code></pre>"},{"location":"parameter_analysis.html#2-solve-for-optimal-parameters","title":"2. Solve for Optimal Parameters","text":"<pre><code>solver = ConstrainedSolver()\ntheta_opt, active_mask = solver.solve(K, r, param_def)\n</code></pre>"},{"location":"parameter_analysis.html#3-sample-the-nullspace","title":"3. Sample the Nullspace","text":"<pre><code>samples = solver.sample(\n    K, r, param_def,\n    n_samples=1000,\n    x_center=theta_opt\n)\n# samples shape: (1000, n_params)\n</code></pre>"},{"location":"parameter_analysis.html#parameter-reference","title":"Parameter Reference","text":"<p>The reverse analysis optimizes the following parameters for each functional group:</p> Parameter Name Description Contribution <code>Base Inflow</code> Environmental Inflow Source for Env <code>Uptake_{i}</code> Direct Absorption Rate Gain for Group \\(i\\), Loss for Env <code>MetaDecay_{i}</code> Metabolic Decay Rate Loss for Group \\(i\\), Gain for Env <code>PhysDecay_{i}</code> Physical Decay Rate Loss for Group \\(i\\) (leaves system) <code>AE_{i}</code> Assimilation Efficiency Scales gain from diet <code>ImmigConc_{i}</code> Immigration Concentration Source for Group \\(i\\)"}]}